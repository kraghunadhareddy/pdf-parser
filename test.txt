import pytesseract
from pdf2image import convert_from_path
from PIL import Image, ImageEnhance, ImageFilter
import cv2
import numpy as np
import json
import os
import argparse
from difflib import SequenceMatcher
from collections import defaultdict
import pprint
import re

pytesseract.pytesseract.tesseract_cmd = r"C:\Program Files\Tesseract-OCR\tesseract.exe"

class CheckboxExtractor:
    def __init__(self, poppler_path=None, ticked_template_path=None, empty_template_path=None, match_threshold=0.6):
        self.poppler_path = poppler_path
        self.match_threshold = match_threshold
        self.ticked_template = cv2.imread(ticked_template_path, cv2.IMREAD_GRAYSCALE)
        self.empty_template = cv2.imread(empty_template_path, cv2.IMREAD_GRAYSCALE)
        if self.ticked_template is None or self.empty_template is None:
            raise ValueError("❌ Failed to load one or both template images.")
        self.template_size = self.ticked_template.shape[::-1]

    def preprocess_image(self, image):
        image = image.convert("RGB")
        image = image.filter(ImageFilter.SHARPEN)
        enhancer = ImageEnhance.Contrast(image)
        image = enhancer.enhance(1.2)
        return image

    def match_template(self, image_gray, template, label):
        result = cv2.matchTemplate(image_gray, template, cv2.TM_CCOEFF_NORMED)
        locations = np.where(result >= self.match_threshold)
        matches = []
        for pt in zip(*locations[::-1]):
            x, y = pt
            score = float(result[y, x])
            matches.append({
                "position": [int(x), int(y), self.template_size[0], self.template_size[1]],
                "score": round(score, 2),
                "label": label,
                "status": label,
                "confidence": round(score, 2)
            })
        return matches

    def deduplicate_matches(self, ticked_matches, empty_matches, max_dist=5):
        all_boxes = []

        # Tag status
        for box in ticked_matches:
            box["status"] = "ticked"
            all_boxes.append(box)
        for box in empty_matches:
            box["status"] = "empty"
            all_boxes.append(box)

        # Sort by confidence descending
        all_boxes.sort(key=lambda b: b["confidence"], reverse=True)

        deduped = []
        for box in all_boxes:
            x, y, w, h = box["position"]
            is_duplicate = False
            for existing in deduped:
                ex, ey, ew, eh = existing["position"]
                if abs(x - ex) < max_dist and abs(y - ey) < max_dist:
                    is_duplicate = True
                    break
            if not is_duplicate:
                deduped.append(box)

        return sorted(deduped, key=lambda b: (b["position"][1], b["position"][0]))

    def detect_checkboxes(self, pil_image):
        img = np.array(pil_image)
        gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
        ticked_matches = self.match_template(gray, self.ticked_template, "ticked")
        empty_matches = self.match_template(gray, self.empty_template, "empty")
        boxes = self.deduplicate_matches(ticked_matches, empty_matches)
        
        print("[CHECKBOX POSITIONS]")
        for i, box in enumerate(boxes):
            print(f"  Checkbox {i}: {box}, type={type(box)}")

        print(f"Template matches: {len(boxes)} checkboxes detected")
        return boxes, img

    def get_label_positions(self, pil_image, expected_labels, match_threshold=0.8):
        ocr_data = pytesseract.image_to_data(pil_image, output_type=pytesseract.Output.DICT)
        label_positions = defaultdict(list)

        tokens = []
        for i in range(len(ocr_data["text"])):
            word = ocr_data["text"][i].strip()
            if not word:
                continue
            norm = word.replace("/", "").replace(" ", "").replace("-", "").lower()
            tokens.append({
                "text": norm,
                "orig": word,
                "x": ocr_data["left"][i],
                "y": ocr_data["top"][i]
            })

        for lbl in expected_labels:
            lbl_norm = lbl.replace("/", "").replace(" ", "").replace("-", "").lower()
            for i in range(len(tokens)):
                score = SequenceMatcher(None, lbl_norm, tokens[i]["text"]).ratio()
                if score >= match_threshold:
                    label_positions[lbl].append((tokens[i]["x"], tokens[i]["y"]))
                if i < len(tokens) - 1:
                    merged = tokens[i]["text"] + tokens[i + 1]["text"]
                    score = SequenceMatcher(None, lbl_norm, merged).ratio()
                    if score >= match_threshold:
                        label_positions[lbl].append((tokens[i]["x"], tokens[i]["y"]))

        print("[LABEL POSITIONS]")
        for lbl, positions in label_positions.items():
            for pos in positions:
                print(f"  Label '{lbl}' matched at (x={pos[0]}, y={pos[1]})")

        return label_positions

    def detect_section_regions(self, pil_image, sections, label_positions, checkbox_positions, max_gap=100):
        ocr_data = pytesseract.image_to_data(pil_image, output_type=pytesseract.Output.DICT)
        lines = {}
        for i in range(len(ocr_data["text"])):
            word = ocr_data["text"][i].strip()
            if not word:
                continue
            line_id = (ocr_data["block_num"][i], ocr_data["par_num"][i], ocr_data["line_num"][i])
            if line_id not in lines:
                lines[line_id] = {
                    "text": word,
                    "x": ocr_data["left"][i],
                    "y": ocr_data["top"][i],
                    "h": ocr_data["height"][i]
                }
            else:
                lines[line_id]["text"] += " " + word

        sorted_lines = sorted(lines.values(), key=lambda l: l["y"])
        checkbox_y_positions = sorted([cb["position"][1] for cb in checkbox_positions])
        section_regions = {}

        for section in sections:
            section_name = section["section_name"]
            anchor_y = None
            for line in sorted_lines:
                if re.search(r"\b" + re.escape(section_name.lower()) + r"\b", line["text"].lower()):
                    anchor_y = line["y"]
                    print(f"[ANCHOR TEXT] '{line['text']}' matched section '{section_name}' at y={anchor_y}")
                    break
            if anchor_y is None:
                print(f"[WARN] No anchor found for section '{section_name}'")
                continue

            # Extend downward until checkbox silence
            y2 = anchor_y
            last_cb_y = None
            for cb_y in checkbox_y_positions:
                if cb_y < anchor_y:
                    continue
                if last_cb_y is None or cb_y - last_cb_y <= max_gap:
                    y2 = cb_y
                    last_cb_y = cb_y
                else:
                    break

            section_regions[section_name] = {
                "x1": 0,
                "y1": anchor_y,
                "x2": 2000,
                "y2": y2 + 50  # small buffer
            }
            print(f"[MATCH] Section '{section_name}' anchored at y={anchor_y}, extended to y={y2 + 50}")

        return section_regions

    def filter_checkboxes_in_region(self, checkboxes, region):
        return [box for box in checkboxes if region["y1"] <= box["position"][1] <= region["y2"]]

    def cluster_checkboxes_by_rows(self, checkboxes, gap_threshold=50):
        sorted_boxes = sorted(checkboxes, key=lambda b: b["position"][1])
        rows = []
        current_row = []

        for i, box in enumerate(sorted_boxes):
            y = box["position"][1]
            if not current_row:
                current_row.append(box)
                continue

            prev_y = current_row[-1]["position"][1]
            if abs(y - prev_y) > gap_threshold:
                rows.append({
                    "y": sum(b["position"][1] for b in current_row) / len(current_row),
                    "boxes": current_row
                })
                current_row = [box]
            else:
                current_row.append(box)

        if current_row:
            rows.append({
                "y": sum(b["position"][1] for b in current_row) / len(current_row),
                "boxes": current_row
            })

        return rows

    def assign_checkboxes_sectionwise(self, checkboxes, sections, label_positions, section_regions,
                                    column_tolerance=100, min_row_gap=60):
        output_sections = []

        for sec in sections:
            sec_name = sec["section_name"]
            if sec_name not in section_regions:
                print(f"[WARN] Skipping section '{sec_name}' — no region found")
                continue

            region = section_regions[sec_name]
            section_boxes = self.filter_checkboxes_in_region(checkboxes, region)
            print(f"[INFO] Section '{sec_name}' has {len(section_boxes)} checkboxes in region y={region['y1']}–{region['y2']}")

            rows = self.cluster_checkboxes_by_rows(section_boxes, gap_threshold=50)
            for row in rows:
                row["boxes"] = sorted(row["boxes"], key=lambda b: b["position"][0])

            print(f"[DEBUG] Section '{sec_name}' clustered into {len(rows)} rows")
            for i, row in enumerate(rows):
                print(f"  Row {i}: y={row['y']:.1f}, boxes={len(row['boxes'])}")

            sec_checkboxes = []
            used_boxes = set()

            for lbl in sec["labels"]:
                if lbl not in label_positions:
                    print(f"[MISS] Label '{lbl}' not found in OCR")
                    continue

                for lx, ly in label_positions[lbl]:
                    if not (region["y1"] <= ly <= region["y2"]):
                        print(f"[SKIP] Label '{lbl}' at y={ly} is outside section '{sec_name}' bounds ({region['y1']}–{region['y2']})")
                        continue

                    closest_box = min(section_boxes, key=lambda cb: abs(cb["position"][1] - ly) + abs(cb["position"][0] - lx))
                    cb_x, cb_y, _, _ = closest_box["position"]

                    best_row = next((row for row in rows if closest_box in row["boxes"]), None)
                    if best_row is None or abs(best_row["y"] - ly) > min_row_gap:
                        print(f"[MISS] Label '{lbl}' is too far from any row (delta_y={abs(best_row['y'] - ly):.1f})")
                        sec_checkboxes.append({
                            "label": lbl,
                            "status": "missing",
                            "score": 0.0,
                            "confidence": 0.0,
                            "position": [0, 0, 0, 0]
                        })
                        continue

                    box_id = id(closest_box)
                    if box_id in used_boxes:
                        print(f"[MISS] Label '{lbl}' closest checkbox already used")
                        sec_checkboxes.append({
                            "label": lbl,
                            "status": "missing",
                            "score": 0.0,
                            "confidence": 0.0,
                            "position": [0, 0, 0, 0]
                        })
                        continue

                    used_boxes.add(box_id)
                    print(f"[MATCHED] Label '{lbl}' assigned to checkbox at ({cb_x}, {cb_y}) in section '{sec_name}'")
                    sec_checkboxes.append({
                        "label": lbl,
                        "status": closest_box["status"],
                        "score": closest_box["score"],
                        "confidence": closest_box["confidence"],
                        "position": closest_box["position"]
                    })

            print(f"[FINAL CHECKBOXES FOR SECTION '{sec_name}']")
            for cb in sec_checkboxes:
                print(f"  {cb['label']} -> {cb['status']} @ {cb['position']}")

            output_sections.append({
                "section": sec_name,
                "checkboxes": sec_checkboxes
            })

        return output_sections
   
    def extract_pdf_with_sections(self, pdf_path, sections_file):
        if not os.path.exists(sections_file):
            raise FileNotFoundError(f"Sections JSON file not found: {sections_file}")
        with open(sections_file, "r", encoding="utf-8") as f:
            sections = json.load(f)

        structured_data = {"pages": []}
        pages = convert_from_path(pdf_path, dpi=300, poppler_path=self.poppler_path)
        print(f"Loaded {len(pages)} pages from PDF: {pdf_path}")

        for page_number, page_image in enumerate(pages, start=1):
            print(f"Processing page {page_number}")
            processed_img = self.preprocess_image(page_image)
            checkboxes, raw_img = self.detect_checkboxes(processed_img)

            all_labels = [lbl for sec in sections for lbl in sec["labels"]]
            label_positions = self.get_label_positions(processed_img, all_labels)
            section_regions = self.detect_section_regions(processed_img, sections, label_positions, checkboxes)

            #print("[LABEL -> CHECKBOX DISTANCES]")
            #for lbl, (lx, ly) in label_positions.items():
                #if not checkboxes:
                    #print(f"[WARN] No checkboxes detected on page {page_number}, skipping distance calc for label '{lbl}'")
                    #continue
                #closest = min(checkboxes, key=lambda cb: abs(cb['position'][1] - ly) + abs(cb['position'][0] - lx))
                #cb_x, cb_y = closest['position'][0], closest['position'][1]
                #dy = abs(cb_y - ly)
                #dx = abs(cb_x - lx)
                #print(f"Label '{lbl}' -> Closest checkbox at (x={cb_x}, y={cb_y}) | Delta-x={dx}, Delta-y={dy}")

            for section in sections:
                sec_name = section["section_name"]
                if sec_name not in section_regions:
                    continue
                region = section_regions[sec_name]
                for lbl in section["labels"]:
                    if lbl not in label_positions:
                        continue
                    for pos in label_positions[lbl]:
                        lx, ly = pos
                    if not (region["y1"] <= ly <= region["y2"]):
                        print(f"[SKIP] Label '{lbl}' at y={ly} is outside section '{sec_name}' bounds ({region['y1']}–{region['y2']})")
                        continue
                    section_boxes = self.filter_checkboxes_in_region(checkboxes, region)
                    if not section_boxes:
                        print(f"[SKIP] No checkboxes in section '{sec_name}' for label '{lbl}'")
                        continue
                    closest = min(section_boxes, key=lambda cb: abs(cb['position'][1] - ly) + abs(cb['position'][0] - lx))
                    cb_x, cb_y = closest['position'][0], closest['position'][1]
                    dy = abs(cb_y - ly)
                    dx = abs(cb_x - lx)
                    print(f"[LABEL -> CHECKBOX] Section '{sec_name}' | Label '{lbl}' -> Closest checkbox at (x={cb_x}, y={cb_y}) | Delta-x={dx}, Delta-y={dy}")

            sections_data = self.assign_checkboxes_sectionwise(
                checkboxes, sections, label_positions, section_regions
            )

            self.annotate_debug_image(raw_img, sections_data, label_positions, page_number, section_regions)

            structured_data["pages"].append({
                "page_number": page_number,
                "sections": sections_data
            })

        print("[FINAL STRUCTURED DATA]")
        pprint.pprint(structured_data)

        return structured_data

    def annotate_debug_image(self, img, sections_data, label_positions, page_number, section_regions=None):
        if section_regions:
            for name, region in section_regions.items():
                cv2.rectangle(img, (region["x1"], region["y1"]), (region["x2"], region["y2"]), (255, 0, 0), 2)
                cv2.putText(img, name, (region["x1"], region["y1"] - 10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)

        for section in sections_data:
            for box in section["checkboxes"]:
                x, y, w, h = box["position"]
                label = box.get("label", "?")
                score = box.get("score", 0.0)
                status = box.get("status", "unknown")

                color = {
                    "ticked": (0, 255, 0),
                    "empty": (0, 0, 255),
                    "missing": (0, 255, 255)
                }.get(status, (128, 128, 128))

                cv2.rectangle(img, (x, y), (x + w, y + h), color, 2)
                cv2.putText(img, f"{label} ({status} S:{score:.2f})", (x, y - 5),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.45, color, 1)

                if label in label_positions:
                    for pos in label_positions[label]:
                        if len(pos) >= 2:
                            lx, ly = pos
                            cv2.arrowedLine(img, (lx, ly), (x, y), color, 1, tipLength=0.2)
                        else:
                            print(f"[WARN] Malformed label position for '{label}': {pos}")

        cv2.imwrite(f"debug_page_{page_number}.png", img)

class NpEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.integer): return int(obj)
        if isinstance(obj, np.floating): return float(obj)
        if isinstance(obj, np.ndarray): return obj.tolist()
        return super().default(obj)

def main():
    parser = argparse.ArgumentParser(description="PDF Checkbox Extractor with Section-Aware Label Alignment")
    parser.add_argument("--pdf", required=True, help="Path to PDF file")
    parser.add_argument("--sections", required=True, help="Path to sections.json")
    parser.add_argument("--output", default="output.json", help="Output JSON file")
    parser.add_argument("--ticked_template", required=True, help="Path to ticked checkbox image")
    parser.add_argument("--empty_template", required=True, help="Path to empty checkbox image")
    parser.add_argument("--poppler", default=r"C:\Users\raghu\Downloads\Release-25.07.0-0\poppler-25.07.0\Library\bin",
                        help="Path to poppler bin directory")
    parser.add_argument("--threshold", type=float, default=0.6, help="Template match threshold (0–1)")
    args = parser.parse_args()

    extractor = CheckboxExtractor(
        poppler_path=args.poppler,
        ticked_template_path=args.ticked_template,
        empty_template_path=args.empty_template,
        match_threshold=args.threshold
    )

    print(f"Starting extraction for: {args.pdf}")
    data = extractor.extract_pdf_with_sections(args.pdf, args.sections)

    print(f"Writing structured data to {args.output}")
    with open(args.output, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False, cls=NpEncoder)

    print(f"Extraction complete! Data saved to {args.output}")

if __name__ == "__main__":
        main()